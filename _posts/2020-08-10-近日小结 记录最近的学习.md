---
title: 2020-08-10-近日小结 记录最近的学习
tags: 分布式B+树,学习,研究
renderNumberedHeading: true
grammar_cjkRuby: true
---


暑假决定留校跟随导师做些研究以开拓眼界，导师是做数据库的所以交给我以及我的partner研究改进现有的数据库分布式B+树索引构建。
而我目前负责的部分是改进现有分布式系统间的数据压缩与传递效率的问题。

# GRPC
gRPC是什么可以用官网的一句话来概括
Ahigh-performance, open-source universal RPC framework

所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。如下图所示就是一个典型的RPC结构图。

RPC通信gRPC有什么好处以及在什么场景下需要用gRPC 
既然是server/client模型，那么我们直接用restful api不是也可以满足吗，为什么还需要RPC呢?下面我们就来看看RPC到底有哪些优势

gRPC vs. Restful API 
gRPC和restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而restful api则不一定)。不过gRPC还是有些特有的优势，如下:
gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。关于protobuf可以参见笔者之前的小文Google Protobuf简明教程另外，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。)使用场景 需要对接口进行严格约束的情况，比如我们提供了一个公共的服务，很多人，甚至公司外部的人也可以访问这个服务，这时对于接口我们希望有更加严格的约束，我们不希望客户端给我们传递任意的数据，尤其是考虑到安全性的因素，我们通常需要对接口进行更加严格的约束。这时gRPC就可以通过protobuf来提供严格的接口约束。对于性能有更高的要求时。有时我们的服务需要传递大量的数据，而又希望不影响我们的性能，这个时候也可以考虑gRPC服务，因为通过protobuf我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过http2我们可以实现异步的请求，从而大大提高了通信效率。

# GRPC自带PB

		GRPC自带的PB对于数据的压缩还算不错，但如果是大数据的话仍然不够理想，而不巧的是我们所研究的数据库正是存在着流式大数据传送，这降低了索引构建的效率。
		

	为此我决定了解PB压缩数据算法的实质，PB采用的是对Varints 编码的应用，而只要压缩算法与其不冲突应该就可以实现.
		Varint 确实是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。
		
300 如果用 int32 表示，需要 4 个字节，现在用 Varint 表示，只需要 2 个字节了。缩小了一半！
# 优化
		首先我们需要分析主要的耗时在那个环节？我们对该调用链路进行简单的梳理：
客户端将请求对象序列化为pb--网络IO--服务反序列化对象--业务计算--计算结果序列化--网络IO--客户端对响应反序列化
对整个流程中的分阶段耗时进行统计分析，发现目前主要的耗时在序列化的过程，也就是说目前的pb序列化性能不符合预期！怎么优化呢？序列化的过程是cpu密集型的，既然pb序列化无法满足，那我们就寻求性能更好的序列化方式.

例如 flat buffer

pb和fb各有裨益，在内存空间占用这个指标上，flat buffers占用的内存空间比protobuf多了两倍。序列化时二者的cpu计算时间fb比pb快，当然反序列化时二者的cpu计算时间fb比pb也要快。即fb在计算时间上占优势，而pb则在内存空间上占优。

而此时虽然序列化被优化了，但是传输的数据包也更大了，这时候我们该考虑压缩数据包了。

压缩方法比较多，GZIP、LZO、Zippy/Snappy压缩等方法众多，我们需要选择适合我们的那一款。这几款压缩也是hbase中应用的几种压缩方式。我们对其特点做一个分析，其中：
1）GZIP的压缩率最高，但是其是CPU密集型的，对CPU的消耗比其他算法要多，压缩和解压速度也慢；
2）LZO的压缩率居中，比GZIP要低一些，但是压缩和解压速度明显要比GZIP快很多，其中解压速度快的更多；
3）Zippy/Snappy的压缩率最低，而压缩和解压速度要稍微比LZO要快一些。

BigTable中采用的是Zippy算法，目标是达到尽可能快的压缩和解压速度，同时减少对CPU的消耗。

# 总结
分析阶段到此为止，确定了两个实践方向。一是使用PB搭配压缩算法实现，二是使用FB搭配压缩算法实现。分析结果选取最终的策略。